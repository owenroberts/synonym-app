extends layout
block content
	div.error
		div.msg
			div.sorry
			div.errormsg
			div.ok
				div="OK"
	div.definition
		div.msg
			div.word
			div.pos
			div.def
			div.ok
				div="OK"

	div#newpath
		ul
			li
				img(src="/images/loader.svg" width="60px" style="margin:1em;")

	div#main
		header
			div.menu
				a(href="/")
					svg(width="22" height="22" viewBox="0 0 20 20" class="stroke")
						path(fill="none" stroke="#C7C8CA" stroke-width="2" stroke-linecap="round" d="M17.2 7.6H1.1M17.2 1.2H1.1M17.2 14H1.1")
			div.plus
				svg(width="20" height="20" viewBox="0 0 20 20" class="stroke")
					g(fill="none")
					path(d="M9.6 1v17.1M18.1 9.6H1" stroke="#C7C8CA" stroke-width="2" stroke-linecap="round")
											

		div.path-dots.slidedown.pathdotcontainer
			div.leftarrow
				img(src="/images/left-arrow.svg")
			div.rightarrow
				img(src="/images/right-arrow.svg")
			div.dots
				div.path-dot(id="p-0")

		div#paths		
			div.path(id="path-0")
				div.nodes
					div.node-dad=data.start
					each node, index in data.path
						div.node-dad
							div.inner-nodes
								if node.alternates
									for alt in node.alternates
										if alt == node.node
											div.node.thenode=alt
										else
											div.node.alternate=alt
								else
									div.node.thenode=node.node

					div.node-dad=data.end
								

									
	// javascript // 
	script(type='text/javascript').

		$(document).ready( function() {


		$('a').on('click', function(ev) {
			ev.preventDefault();
			window.location = this.href;
		});

		function getRandomInt(min, max) {
			return Math.floor(Math.random()* ( max - min + 1) + min);
		}

		function reportError(err, option) {
			$('.error').fadeIn();
			$('.sorry').html(err);
			$('.errormsg').html(option);
			$('.error .ok').on('click', function() {
				$('.error').fadeOut();
			});
		}

		// ** blogal variables ** //
		var debug = false;
		var fadeDur = debug ? 10 : 500;

		var w = window.innerWidth;
		var pathNum = 0;
		var currentPathNum = pathNum;
		var pathData = !{JSON.stringify(data)};
		//console.log(pathData);
		if (pathData.error) reportError(pathData.error);
		var start = pathData.start;
		var end = pathData.end;
		var nodelimitArray = [+pathData.nodelimit];
		var nomorepaths = false;

		var noTouching = false;


		// ** animate nodes on load ** //
		$('.path:first-child .nodes').each( function() {
			var nodes = $('.node-dad');
			for (var i = 0; i < nodes.length; i++) {
				var showNode = function(num) {
					setTimeout( function() {
						$(nodes[num]).fadeIn(fadeDur);
					}, num*fadeDur);
				}(i);
			}
		});
		$('.path:gt(1) .node-dad').css({display:'block'});

		// ** move nodes to "thenode" //
		$('.inner-nodes').each( function() {
			var i = $(this).find('.thenode').index();
			$(this).animate({
				left: -300 * i
			}, fadeDur);
		});

		// ** inner nodes, matching container width ** //
		var nodedads = $('.node-dad');
		for (var i = 1; i < nodedads.length - 1; i++) {
			var inner = $(this).find('.inner-nodes');
			var innerwidth = 0;
			var nodes = $(inner).find('.node');
			for (var h = 0; h < nodes.length; h++) {
				innerwidth += $(nodes[h]).innerWidth();
			}
			$(inner).css({width:innerwidth});
			$(nodedads[i]).css({width:innerwidth + 48});
		}

		// ** fade in ui ** //
		$('.fadein').animate({
			opacity: 1
		}, fadeDur*2);

		function getNewPath(ev) {
			ev.stopPropagation();
			if (!nomorepaths) {
				$('#newpath').fadeIn(fadeDur);
				$('.plus').removeClass('rotate');
				makeNewPath();
			} else {
				reportError("The algorithm is not able to generate more results based on the current parameters.");
			}
		}

		// ** plus button for new paths ** //
		function makeNewPath() {

			var nodelimit;
			if (pathNum < 10) {

				do {
					nodelimit = getRandomInt(2,20);
				} while (nodelimitArray.indexOf(nodelimit) != -1);
				//nodelimit = 2; // break it for testing
				nodelimitArray.push(nodelimit);
				
				
				var synonymlevel = 10;  // should synonym level be randomized?

				$.ajax({
					url: '/search/add',
					type: 'get',
					dataType:'json',
					data: {
						start: start,
						end: end,
						synonymlevel: synonymlevel,
						nodelimit: nodelimit
					},
					success: function(obj) {
						$('#newpath').fadeOut(fadeDur);
						if (obj.errormsg) {
							if (nodelimitArray.length < 9) {
								makeNewPath();
							} else {
								nomorepaths = true;
								reportError("The algorithm is not able to generate more results based on the current parameters.");
							}
						} else {
							var data = obj.data;
							$('.plus').addClass('rotate');
							currentPathNum++;
							pathNum++;
							var newdot = $('<div>')
								.attr({id:"p-"+currentPathNum})
								.addClass('path-dot');
							$('.dots').append(newdot);
							$('.path-dot').css({color:'lightgray'});
							newdot.css({color:'black'});

							var newpath = $('<div>')
								.attr({id:"path-"+currentPathNum})
								.addClass('path')
								.css({left:currentPathNum*w});
							var newnodes = $('<div>')
								.addClass('nodes');
							newpath.append(newnodes);
							var startnodedad = $('<div>')
								.addClass('node-dad')
								.text(start);
							newnodes.append(startnodedad);
							for (var i = 0; i < data.path.length; i++) {
								var node = data.path[i];
								var anewnodedad = $('<div>')
									.addClass('node-dad');
								var innerwidth = 0;
								newnodes.append(anewnodedad);
								var innernodes = $('<div>')
									.addClass('inner-nodes');
								anewnodedad.append(innernodes);
								if (node.alternates) {
									for (var h = 0; h < node.alternates.length; h++) {
										innerwidth += w;
										var alt = node.alternates[h];
										if (alt == node.node) {
											var thenode = $('<div>')
												.addClass('node thenode')
												.text(alt);
										} else {
											var thenode = $('<div>')
												.addClass('node alternate')
												.text(alt);
										}
										innernodes.append(thenode);
									}
								}
								innernodes.css({width:innerwidth});
								anewnodedad.css({width:innerwidth + 48});
							}
							var endnodedad = $('<div>')
								.addClass('node-dad')
								.text(end);
							newnodes.append(endnodedad);
							$('#paths').append(newpath);
							newpath.find('.nodes').each( function() {
								var nodes = $(this).find('.node-dad');
								for (var i = 0; i < nodes.length; i++) {
									var showNode = function(num) {
										setTimeout( function() {
											$(nodes[num]).fadeIn(fadeDur);
										}, num*fadeDur);
									}(i);
								}
							});


							newpath.find('.inner-nodes').each( function() {
								var i = $(this).find('.thenode').index();
								$(this).animate({
									left: -300 * i
								}, fadeDur);
							});

							
							$('.path-dots').slideDown(fadeDur, function() {
								$('#paths').animate({
									left: -currentPathNum * w
								}, fadeDur);
							});

							setPathDots(true);
						}
					}
				});
			} else {
				$('#newpath').fadeOut(fadeDur/2);
				reportError('You have reached the maximum number of paths.');
			}				
		}
		$('.plus').on('click',  getNewPath);
		

		// ** animate path switching  ** //
		var setPathDots = function(next) {
			$('.path-dot').css({color:'lightgray'});
			$('.path-dot:nth-child('+(currentPathNum+1)+')').css({color:'black'});
			if (next) setZIndex();
			$('#paths').animate({
				left: -w * currentPathNum
			}, fadeDur, function() {
				if (!next) setZIndex();
			});	
		}
		var setZIndex = function() {
			var paths = $('#paths').children();
			paths.css({zIndex:1});
			$(paths[currentPathNum]).css({zIndex:9});
		}

		var switchPath = function() {
			var n = false;
			if (currentPathNum < $(this).index()) n = true;
			currentPathNum = $(this).index();
			setPathDots(n);
		};

		var nextPath = function() {
			if (currentPathNum < pathNum) {
				currentPathNum++;
				setPathDots(true);
			}
		};

		var prevPath = function() {
			if (currentPathNum > 0) {
				currentPathNum--;
				setPathDots(false);
			}
		};

		$('.path-dot').on('click', switchPath);
		$( ".path-dots" ).on( "swipeleft", nextPath);
		$('.rightarrow').on('click', nextPath);
		$( ".path-dots" ).on( "swiperight", prevPath);
		$('.leftarrow').on('click', prevPath);

		


		// ** swipe left on nodes ** //
		//-  taking about "modified" bool here, not sure what it should do
		$( 'body' ).on( "swipeleft", ".node", function() {
			if (!noTouching) animateNodes(this, 1, "-=300");	
		});
		$( 'body' ).on( "swiperight", ".node", function() {
			if (!noTouching) animateNodes(this, 0, "+=300");	
		});

		function animateNodes(elem, dir, animProp) {
			noTouching = true;

			var parent = $(elem).parent();
			var grandparent = $(parent).parent();

			var ldrimg = $('<img>');
			$(ldrimg).attr("src", "/images/loader.svg")
				.addClass('ldrimg')
				.css({width:"24px", position:"absolute", left:"260px", marginTop:"12px"});
			$(grandparent).prepend(ldrimg);
			
			var alt = dir ? $(elem).next() : $(elem).prev();
			if (alt[0]) {
				$(elem).animate({ opacity: 0 }, fadeDur);
				$(alt).animate({  opacity: 1 }, fadeDur);
				$(parent).animate({ left: animProp }, fadeDur);
				modifyChain($(grandparent), $(alt)[0].innerText);
			} else {
				$(elem).addClass('animated shake');
				setTimeout(function() {
					$(elem).removeClass('animated-half shake');
				}, fadeDur);
				noTouching = false;
				$('.ldrimg').remove();
			}	
		}	
		
		// ** modify chain ** //
		function modifyChain(elem, alt) {
			$(elem).find('.dots').html('<img src="/images/loader.svg" />');

			var pathIndex = $(elem).index();
			var pathParent = $(elem).parent().parent().attr('id');
			var nodes = $('#' + pathParent + ' .node-dad:gt('+elem.index()+')');
			var node = $(elem).find('.thenode').text();

			$(nodes).animate({
				opacity: 0.3
			}, fadeDur/2);

			var allsynonyms = [start];

			for (var i = 0; i < pathIndex; i++) {
				allsynonyms = allsynonyms.concat(pathData.path[i].alternates);
			}

			$.ajax({
				url: '/search/modified',
				type: 'get',
				dataType:'json',
				data: {
					start: alt,
					end: end,
					synonymlevel: 10,
					nodelimit: 10 - elem.index(),
					allsynonyms: allsynonyms
				},
				success: function(obj) {
					if (obj.errormsg) {
						var err = 'We couldn\'t find a path between "' + alt + '" and "' + end + '".';
						var option = "Try swiping back to the previous synonym, or forward to the next.";
						reportError(err, option);
						$('.node:contains("'+alt+'")').addClass('mod-error');
						noTouching = false;
						$('.ldrimg').remove();
					} else {
						var data = obj.data;
						$(nodes).animate({
							opacity: 1
						}, fadeDur/2);

						var waitTime = nodes.length * fadeDur/2;
						setTimeout(function() {
								noTouching = false;
						}, waitTime + fadeDur);

						for (var i = 0; i < nodes.length - 1; i++) {
							var n = i;
							$(nodes[i]).fadeOut((nodes.length - i) * fadeDur/2, function(n) {
								this.remove();
							});
						}

						for (var i = 0; i < data.path.length; i ++) {
							var newnodedad = $('<div>')
								.addClass('node-dad');
							
							var inners = $('<div>')
								.addClass('inner-nodes');

							var newnode = $('<div>')
								.addClass('node')
								.text(data.path[i].node);

							inners.append(newnode);
							for (var h = 0; h < data.path[i].alternates.length; h++) {
								if (data.path[i].alternates[h] != data.path[i].node) {
									var newsynnode = $('<div>')
										.addClass('node')
										.addClass('alternate')
										.text(data.path[i].alternates[h]);
										inners.append(newsynnode);
								}
							}
							newnodedad.append(inners);
							newnodedad.insertBefore('#' + pathParent + ' .node-dad:last-child()');
							newnodedad.delay(i * fadeDur/2 + waitTime + fadeDur/2).fadeIn(fadeDur);
						}
						setTimeout(function() {
							$('.ldrimg').remove();
						}, waitTime);
					}
					
				}
			});
		}

		function showDef(word) {
			$('.definition').fadeIn();
			$('.definition .word').html(word);
			$('.definition .pos').html("Retrieving definition");
		}

		function loadDef(def) {
			if (def.errormsg) {
				$('.definition .pos').html(def.errormsg);
				$('.definition .def').html("");
			} else {
				$('.definition .pos').html(def.data.pos);
				$('.definition .def').html(def.data.def);
			}
			$('.definition .ok').on('click', function() {
				$('.definition').fadeOut();
			});
		}

		/* look up word definitions*/
		var getDefinition = function(elem) {
			var word = elem.target.innerText;
			showDef(word);
			var syn;
			if (pathData.path[0].node == word) syn = pathData.start;
			else {
				for (var i = 0; i < pathData.path.length; i++) {
					if (pathData.path[i].node == word) {
						syn = pathData.path[i-1].node;
						break;
					}
				}
			}
			$.ajax({
				url: '/def',
				type: 'get',
				dataType:'json',
				data: {
					word:word,
					syn: syn
				},
				success: function(obj) {
					loadDef(obj);
				}
			});
		}

		$('.node').on('click', getDefinition);


		});